# バックエンド設計

## アーキテクチャ方針

`packages/api` は、機能ごとに責務を分割する **フィーチャーベース（Vertical Slice）アーキテクチャ** を採用する。これにより、コードの凝集性を高め、拡張性とメンテナンス性を向上させる。

### ディレクトリ構成

```
packages/api/src/
├── features/
│   ├── effort/
│   │   ├── index.ts      # ルート定義 (Hono)
│   │   ├── service.ts    # ビジネスロジック
│   │   └── repository.ts # データアクセス (DB)
│   ├── goals/
│   │   # ... (同様の構成)
│   # ... (他のフィーチャー)
│
├── middleware/
│   ├── auth.ts           # 認証ミドルウェア
│   └── logger.ts         # ログミドルウェア
│
├── lib/
│   └── supabase.ts       # Supabaseクライアントの初期化
│
├── index.ts              # アプリケーションのエントリポイント
└── custom-types.ts       # Honoの型拡張など
```

### 各ファイルの責務

フィーチャー内の各ファイルは、以下の通り責務を明確に分離する。

* **`index.ts` (ルーティング層):**
  * HTTPリクエストの受付窓口。
  * Honoのルート定義、リクエスト検証 (Zod)、認証ミドルウェアの適用を行う。
  * `Service`を呼び出し、結果をクライアントに返す。
* **`service.ts` (ビジネスロジック層):**
  * アプリケーション固有のユースケースやビジネスルールを実装する。
  * HTTPの概念には関与しない。
  * `Repository`を介してデータ操作を行う。
* **`repository.ts` (データアクセス層):**
  * データベース (Supabase) との通信を抽象化する。
  * CRUD操作を実装し、`Service`に対して具体的なDB実装を隠蔽する。

## ミドルウェア設計

バックエンドでは、認証などの共通処理をミドルウェアとして実装し、ルートに適用する。

### `jwtAuthMiddleware`

- **責務:**
  - リクエストヘッダーの `Authorization: Bearer <JWT>` からJWTを取得する。
  - Supabaseの `getUser(jwt)` 関数を使い、JWTを検証し、ユーザー情報を取得する。
  - 取得したユーザー情報を、後続のハンドラで利用できるようコンテキスト (`c.set('user', ...)`) に格納する。
  - 検証に失敗した場合は `401 Unauthorized` エラーを返す。
- **適用範囲:**
  - フロントエンドから呼び出される全てのAPIルート (`/api/*`)。ただし、APIキー認証を行う `/api/effort` は除く。

### `apiKeyAuthMiddleware`

- **責務:**
  - リクエストヘッダーの `Authorization: Bearer <APIキー>` から固定APIキーを取得し、環境変数の値と照合する。
  - 検証に成功した場合、リクエストペイロードからメールアドレスを取得し、データベースを検索してユーザー情報を特定する。
  - 特定したユーザー情報をコンテキスト (`c.set('user', ...)`) に格納する。
  - 検証に失敗した場合は `401 Unauthorized` または `400 Bad Request` を返す。
- **適用範囲:**
  - 外部サービスからのリクエストを受信する `/api/effort` ルートに限定して適用する。

## エラーハンドリング

アプリケーション全体で一貫したエラー処理を行うため、以下の設計を採用する。

### カスタムエラークラスの定義

- `Error` クラスを継承したカスタムエラークラス（例: `AppError`）を定義する。
- このクラスは、エラー発生時に必要な情報（HTTPステータスコード、クライアントに返すメッセージ、ログに記録するログレベル、元のエラーオブジェクトなど）をプロパティとして保持する。
  - 例: `statusCode: number`, `message: string`, `logLevel: 'ERROR' | 'CRITICAL'`, `originalError?: unknown`

### エラーのスロー

- 各APIハンドラやビジネスロジック内でエラーが発生した場合、このカスタムエラークラスのインスタンスを生成し、`throw` する。
  - 例: `throw new AppError(400, '入力値が不正です', 'ERROR');`

### グローバルエラーハンドラー

- Honoの `app.onError()` メソッドを使用して、グローバルなエラーハンドラーを設定する。
- このハンドラーは、アプリケーション内でスローされたエラーをすべてキャッチする。
- キャッチしたエラーがカスタムエラークラスのインスタンスである場合、そのプロパティを基に以下の処理を行う。
  1. **ログ記録:**
     - エラークラスの `logLevel`、`message`、`stack_trace`（`err.stack`）などの情報を取得する。
     - `accessLogMiddleware` がコンテキストにセットした `access_log_id` と関連付けて、`error_logs` テーブルにエラー情報を保存する。
  2. **クライアントへのレスポンス:**
     - エラークラスの `statusCode` と `message` を使用して、統一された形式のJSONレスポンスをクライアントに返す。
     - 例: `{ "error": "エラーメッセージ" }`
- カスタムエラークラス以外の予期せぬエラーがスローされた場合は、`500 Internal Server Error` として処理し、詳細なエラー情報はログにのみ記録し、クライアントには一般的なエラーメッセージを返す。

### Googleフォーム連携時のエラー処理

Googleフォームからのリクエスト (`POST /api/effort`) でエラーが発生した場合、バックエンドは詳細なエラーメッセージを含む適切なHTTPステータスコード（4xx or 5xx）をレスポンスとして返す。

エラー通知の責務は、APIを呼び出す側のGoogle Apps Scriptが担う。GASは、APIからのエラーレスポンスを検知した場合、開発者宛にエラー通知メールを送信する。これにより、バックエンドはメール送信の責務から解放される。

